Hola, mas que un procedure es un conjunto de cosas, pero intento explicarte. 
Interleave 2 de 5 no te va a imprimir nada directamente, o sea si tenes el 
string "2013782217301000362013427965354201201120", y lo imprimis con el font 
interleave 2 de 5, te va a imprimir cualquier cosa. 
Tenes que convertir a "2013782217301000362013427965354201201120 ", en una 
serie de caracteres que luego se imprimen con ese font. 
(Esto independientemente del size con que luego lo imprimas) 
En este ejemplo "2013782217301000362013427965354201201120", queda como 
"(D=ÜFAN:0TD=ZÝÏSZ1D;D)", siendo esto ultimo lo que tenes que mandar a 
imprimir. 

El procedure de compilacion no te lo adjunto porque es un xpw, pero para 
visual fox, te lo copio aca abajo : 

// ------------------------------------------------------ 
// * FUNCTION StrToI2of5(tcString) * INTERLEAVED 2 OF 5 
// *------------------------------------------------------ 
// * Convierte un string para ser impreso con 
// * fuente True Type "PF Interleaved 2 of 5" 
// * ó "PF Interleaved 2 of 5 Wide" 
// * ó "PF Interleaved 2 of 5 Text" 
// * Solo caracteres numéricos 
// * USO: StrToI2of5('1234567890') 
// * RETORNA: Caracter 
// *------------------------------------------------------ 
dbase LOCAL lcStart, lcStop, lcRet, lcCheck, lcCar, lnLong, lnI, lnSum, 
lnAux 
dbase lcStart = CHR(40) 
dbase lcStop = CHR(41) 
dbase lcRet = ALLTRIM([!tcString!]) 
// *--- Genero dígito de control 
dbase lnLong = LEN(lcRet) 
dbase lnSum = 0 
dbase lnCount = 1 
dbase FOR lnI = lnLong TO 1 STEP -1 
dbase lnSum = lnSum + VAL(SUBSTR(lcRet,lnI,1)) * IIF(MOD(lnCount,2) = 
0,1,3) 
dbase lnCount = lnCount + 1 
dbase ENDFOR 
dbase lnAux = MOD(lnSum,10) 
dbase lcRet = lcRet + ALLTRIM(STR(IIF(lnAux = 0,0,10 - lnAux))) 
dbase [!digitos!] = lcret 
dbase lnLong = LEN(lcRet) 
// *--- La longitud debe ser par 
dbase IF MOD(lnLong,2) # 0 
dbase lcRet = '0' + lcRet 
dbase lnLong = LEN(lcRet) 
dbase ENDIF 
// *--- Convierto los pares a caracteres 
dbase lcCar = '' 
dbase FOR lnI = 1 TO lnLong STEP 2 
dbase IF VAL(SUBS(lcRet,lnI,2)) < 50 
dbase lcCar = lcCar + CHR(VAL(SUBS(lcRet,lnI,2)) + 48) 
dbase ELSE 
dbase lcCar = lcCar + CHR(VAL(SUBS(lcRet,lnI,2)) + 142) 
dbase ENDIF 
dbase ENDFOR 
// *--- Armo código 
dbase lcRet = lcStart + lcCar + lcStop 
dbase [!barras!] = lcret 
Los parametros de la rule (parm), son: parm(&tcstring,&barras,&factexbar); 

&tcstring = Esto es lo que queres que compile, en el ejemplo seria 
"2013782217301000362455552514253" 
&barras = Esto es el string anterior pero "compilado" 
&factexbar = Esto es similar a &tcstring, pero con el agregado del digito 
verificador, los codigos de barrar interleave 2 of 5 usan un ultimo digito 
verificador. 

O sea, antes de imprimir, deberias pasar tu string por este procedimiento, y 
entonces en tu form, lo que imprimirias seria, segun este ejemplo: &barras 

Una vez que lo ubicas en el form, boton derecho, properties, y destildas el 
autoresize, en font indicas PF interleaved 2 of 5, font style regular, size 
36 
Y luego, como destildaste el autoresize, adapta el ancho y alto de &barras, 
en mi caso, las dimensiones son de 491 x 53. 

Te adjunto un jpg con la imagen completa de gx9, y la seccion del reporte 
que te comento (xcv.jpg) 

Esto es en gx9 y compila en vfox 9 contra sql2008, no lo tengo pasado 
todavia a X, pero deberia ser igual, siendo Java tu caso, deberias adaptar 
el procedimiento de compilacion embebiendo instrucciones Java nativas , 
quizas ya haya algun css en la web o mismo en los foros gx. 

Buscando asi nomas encuentro : 
http://www.keepautomation.com/products/java barcode/barcodes/interleaved25.h 
tml 
http://www.barcodelib.com/java barcode/barcode symbologies/interleaved25.htm 
l 
http://www.idautomation.com/java/font-encoder.html#DataToEncode 

Te copio tambien esto referido al interleaved 2 of 5 
Código Interleaved 2 of 5 
Este es un código de longitud variable, al igual que los códigos 39 y 128. 
El Interleaved 2 of 5 incluye solamente los dígitos numéricos [0..9] y 
comprime dos dígitos numéricos en cada carácter, proporcionando una muy 
buena densidad. Todos los códigos Interleaved 2 of 5 tienen una cantidad par 
de dígitos. 
Cada par de dígitos, se codifica en un caracter formado por una serie de 5 
barras y 5 espacios. 2 de cada 5 barras son anchas, de allí el nombre "2 of 
5". 
Este código tiene un dígito de control que ofrece mas seguridad en la 
lectura. Dicho dígito de control se calcula con el siguiente algoritmo: 
Suma = 0 
Por cada uno de los dígitos a codificar 
Valor corrector = 1 si la posición del dígito es impar 
= 3 si la posición es par 
Suma = Suma + Valor del dígito * Valor corrector 
Final de los dígitos 
Digito de control = 10 - módulo 10 de Suma 
Si Digito de control = 10 
Digito de control = 0 
Final Si 
Los códigos Interleaved 2 of 5 se forman de la siguiente manera: 
Start + Cadena + Check Digit + End 
Suerte!. 

Carlos A.L.Herrero 
Análisis de Sistemas 
Córdoba 93 (B1640GUA) Martínez Bs.As. 
República Argentina 
Tel: 4792-2053 15-4473-6865 
www.datacomsys.com.ar <http://www.datacomsys.com.ar/> 
www.datacomsys.blogspot.com <http://www.datacomsys.blogspot.com/> 